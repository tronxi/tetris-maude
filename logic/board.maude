fmod BOARD is
    pr PIECE .

    sort Board .
    subsort Piece < Board .

    op emptyBoard : -> Board [ctor] .
    op _/_ : Board Board -> Board [ctor assoc comm id: emptyBoard] .

    vars x y : Int .
    var positionList positionList' : PositionList .
    var b : Board .
    var n : Nat .
    var piece : Piece .
    var pieceType pieceType' : PieceType .

    op inactiveInTop : Board -> Bool .
    eq inactiveInTop([(0, y) \ positionList | inactive | pieceType] / b) = true .
    eq inactiveInTop(b) = false [owise] .

    op performDelete : Board Nat -> Board .
    eq performDelete(b, n) =
        if n < 20
        then
            performDelete(performDeleteLine(b, n), s(n))
        else
            b
        fi .

    op performDeleteLine : Board Nat -> Board .
    eq performDeleteLine(b, n) =
        if countInactiveInRow(b, n) == 10
        then
            deleteInactiveInRow(b, n)
        else
            b
        fi .

    op countInactiveInRow : Board Nat -> Nat .
    eq countInactiveInRow(piece / b, n) = countInactiveInRowForPiece(piece, n) + countInactiveInRow(b, n) .
    eq countInactiveInRow(emptyBoard, n) = 0 .

    op deleteInactiveInRow : Board Nat -> Board .
    eq deleteInactiveInRow(piece / b, n) = downPieceGreaterThanRow(deleteInactiveInRowForPiece(piece, n),n) / deleteInactiveInRow(b, n) .
    eq deleteInactiveInRow(emptyBoard, n) = emptyBoard .

    op canDown : Board -> Bool .
    eq canDown([(x, y) \ positionList | active | pieceType] / [(s(x), y) \ positionList' | inactive | pieceType'] / b) 
                = false .
    eq canDown([positionList | active | pieceType] / b) 
        = canDown([positionList | active | pieceType]) [owise] .

    op down : Board Nat -> Board .
    eq down([positionList | active | pieceType] / b, n) =
        if canDown([positionList | active | pieceType] / b)
        then
            down([positionList | active | pieceType]) / b
        else
            [positionList | inactive | pieceType] / b
        fi .
    eq down(b, n) =
        if inactiveInTop(b) 
        then
            initialBoard(n)
        else
            performDelete(b, 0) / randomPiece(n)
        fi [owise] .

    op downAll : Board Nat -> Board .
    eq downAll(b, n) = 
        if canDown(b)
        then
            downAll(down(b, n), n)
        else down(b,n)
        fi .
    
    op canRight : Board -> Bool .
    eq canRight([(x, y) \ positionList | active | pieceType] / [(x, s(y)) \ positionList' | inactive | pieceType'] / b) 
                = false .
    eq canRight([positionList | active  | pieceType] / b) 
        = canRight([positionList | active  | pieceType]) [owise] .

    op right : Board -> Board .
    eq right([positionList | active | pieceType] / b) =
        if canRight([positionList | active | pieceType] / b)
        then
            right([positionList | active | pieceType]) / b
        else
            [positionList | active | pieceType] / b
        fi .
    eq right(b) = b [owise] .

    op canLeft : Board -> Bool .
    eq canLeft([(x, s(y)) \ positionList | active | pieceType] / [(x, y) \ positionList' | inactive | pieceType'] / b) 
                = false .
    eq canLeft([positionList | active | pieceType] / b) 
        = canLeft([positionList | active | pieceType]) [owise] .
    
    op left : Board -> Board .
    eq left([positionList | active | pieceType] / b) =
        if canLeft([positionList | active | pieceType] / b)
        then
            left([positionList | active | pieceType]) / b
        else
            [positionList | active | pieceType] / b
        fi .
    eq left(b) = b [owise] .

    op canRotate : Board Piece -> Bool .
    eq canRotate([(x,y) \ positionList | inactive | pieceType] / b, [(x,y) \ positionList' | active | pieceType']) 
        = false .
    eq canRotate(b, piece) = inRange(piece) [owise] .

    op rotateClockwise : Board -> Board .
    eq rotateClockwise([positionList | active | pieceType] / b) =
        if canRotate([positionList | active | pieceType] / b, rotateClockwise([positionList | active | pieceType]))
        then
            rotateClockwise([positionList | active | pieceType]) / b 
        else 
            [positionList | active | pieceType] / b
        fi .

    op initialBoard : Nat -> Board .
    eq initialBoard(n) = randomPiece(n) .

endfm