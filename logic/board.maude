fmod BOARD is
    pr PIECE .

    sort Board .
    subsort Piece < Board .

    op emptyBoard : -> Board [ctor] .
    op _/_ : Board Board -> Board [ctor assoc comm id: emptyBoard] .

    vars x y : Int .
    var positionList positionList' : PositionList .
    var b : Board .
    var n : Nat .
    var piece : Piece .

    op inactiveInTop : Board -> Bool .
    eq inactiveInTop([(0, y) \ positionList | inactive] / b) = true .
    eq inactiveInTop(b) = false [owise] .

    op performDelete : Board Nat -> Board .
    eq performDelete(b, n) =
        if n < 20
        then
            performDelete(performDeleteLine(b, n), s(n))
        else
            b
        fi .

    op performDeleteLine : Board Nat -> Board .
    eq performDeleteLine(b, n) =
        if countInactiveInRow(b, n) == 10
        then
            deleteInactiveInRow(b, n)
        else
            b
        fi .

    op countInactiveInRow : Board Nat -> Nat .
    eq countInactiveInRow(piece / b, n) = countInactiveInRowForPiece(piece, n) + countInactiveInRow(b, n) .
    eq countInactiveInRow(emptyBoard, n) = 0 .

    op deleteInactiveInRow : Board Nat -> Board .
    eq deleteInactiveInRow(piece / b, n) = downPieceGreaterThanRow(deleteInactiveInRowForPiece(piece, n),n) / deleteInactiveInRow(b, n) .
    eq deleteInactiveInRow(emptyBoard, n) = emptyBoard .

    op canDown : Board -> Bool .
    eq canDown([(x, y) \ positionList | active ] / [(s(x), y) \ positionList' | inactive ] / b) 
                = false .
    eq canDown([positionList | active ] / b) 
        = canDown([positionList | active ]) [owise] .

    op down : Board Nat -> Board .
    eq down([positionList | active] / b, n) =
        if canDown([positionList | active] / b)
        then
            down([positionList | active]) / b
        else
            [positionList | inactive] / b
        fi .
    eq down(b, n) =
        if inactiveInTop(b) 
        then
            initialBoard
        else
            performDelete(b, 0) / randomPiece(n)
        fi [owise] .

    op downAll : Board Nat -> Board .
    eq downAll(b, n) = 
        if canDown(b)
        then
            downAll(down(b, n), n)
        else b
        fi .
    
    op canRight : Board -> Bool .
    eq canRight([(x, y) \ positionList | active ] / [(x, s(y)) \ positionList' | inactive ] / b) 
                = false .
    eq canRight([positionList | active ] / b) 
        = canRight([positionList | active ]) [owise] .

    op right : Board -> Board .
    eq right([positionList | active] / b) =
        if canRight([positionList | active] / b)
        then
            right([positionList | active]) / b
        else
            [positionList | active] / b
        fi .
    eq right(b) = b [owise] .

    op canLeft : Board -> Bool .
    eq canLeft([(x, s(y)) \ positionList | active ] / [(x, y) \ positionList' | inactive ] / b) 
                = false .
    eq canLeft([positionList | active ] / b) 
        = canLeft([positionList | active ]) [owise] .
    
    op left : Board -> Board .
    eq left([positionList | active] / b) =
        if canLeft([positionList | active] / b)
        then
            left([positionList | active]) / b
        else
            [positionList | active] / b
        fi .
    eq left(b) = b [owise] .

    op initialBoard : -> Board .
    eq initialBoard = [(21, 21) | inactive] / randomPiece(4) .

endfm